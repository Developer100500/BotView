# Система шкал времени и цены

## Обзор

Реализована система отрисовки шкал времени и цены с автоматическими подписями и сеткой для торгового графика. Система использует данные из `ViewportClippingCoords` для определения видимого диапазона и автоматически адаптируется к различным уровням масштабирования.

## Компоненты системы шкал

### 1. Шкала времени (горизонтальная ось)

**Расположение**: Внизу графика
**Данные**: Используется `viewport.minTime` и `viewport.maxTime`

**Особенности**:
- Автоматический расчет оптимального интервала меток
- Адаптивное форматирование подписей в зависимости от масштаба
- Риски и подписи времени

**Форматы подписей**:
- Секунды: `HH:mm:ss`
- Минуты: `HH:mm`
- Часы: `HH:mm`
- Дни: `dd.MM`
- Недели и больше: `dd.MM.yy`

### 2. Шкала цены (вертикальная ось)

**Расположение**: Справа от графика
**Данные**: Используется `viewport.minPrice` и `viewport.maxPrice`

**Особенности**:
- Автоматический расчет оптимального интервала меток
- Адаптивное форматирование в зависимости от величины цены
- Риски и подписи цены

**Форматы подписей**:
- ≥1000: `F0` (без дробной части)
- ≥100: `F1` (1 знак после запятой)
- ≥10: `F2` (2 знака после запятой)
- ≥1: `F3` (3 знака после запятой)
- <1: `F4` (4 знака после запятой)

### 3. Сетка

**Компоненты**:
- Горизонтальные линии (по уровням цены)
- Вертикальные линии (по временным меткам)
- Пунктирный стиль для ненавязчивости

## Алгоритмы расчета интервалов

### Интервал времени

```csharp
private TimeSpan CalculateOptimalTimeInterval()
{
    TimeSpan viewportRange = viewport.maxTime - viewport.minTime;
    double totalSeconds = viewportRange.TotalSeconds;
    int targetTickCount = 8; // Целевое количество меток
    double secondsPerTick = totalSeconds / targetTickCount;
    
    // Выбор подходящего интервала
    if (secondsPerTick <= 60) // Секунды
        return TimeSpan.FromSeconds(Math.Max(1, Math.Round(secondsPerTick / 10) * 10));
    else if (secondsPerTick <= 3600) // Минуты
        return TimeSpan.FromMinutes(Math.Max(1, Math.Round(secondsPerTick / 60 / 5) * 5));
    // ... и так далее
}
```

### Интервал цены

```csharp
private double CalculateOptimalPriceInterval()
{
    double priceRange = viewport.maxPrice - viewport.minPrice;
    int targetTickCount = 8;
    double rawInterval = priceRange / targetTickCount;
    
    // Округление до "красивого" числа (1, 2, 5, 10, 20, 50, 100...)
    double magnitude = Math.Pow(10, Math.Floor(Math.Log10(rawInterval)));
    double normalizedInterval = rawInterval / magnitude;
    
    if (normalizedInterval <= 1) return magnitude;
    else if (normalizedInterval <= 2) return 2 * magnitude;
    else if (normalizedInterval <= 5) return 5 * magnitude;
    else return 10 * magnitude;
}
```

## Методы отрисовки

### DrawTimeScale()
- Отрисовывает горизонтальную линию шкалы
- Вычисляет и отрисовывает временные метки
- Форматирует подписи времени
- Центрирует текст относительно рисок

### DrawPriceScale()
- Отрисовывает вертикальную линию шкалы
- Вычисляет и отрисовывает ценовые метки
- Форматирует подписи цены
- Позиционирует текст справа от рисок

### DrawGrid()
- Отрисовывает пунктирные линии сетки
- Использует те же интервалы, что и шкалы
- Обеспечивает лучшую читаемость графика

## Настройки отступов

```csharp
private double leftMargin = 10;    // Минимальный отступ слева
private double rightMargin = 80;   // Место для шкалы цены
private double topMargin = 20;     // Минимальный отступ сверху
private double bottomMargin = 40;  // Место для шкалы времени
```

## Адаптивность

### Автоматическое масштабирование
- Интервалы меток автоматически адаптируются к уровню zoom
- При увеличении масштаба появляются более детальные метки
- При уменьшении масштаба метки становятся более редкими

### Форматирование подписей
- Формат времени зависит от временного диапазона viewport
- Формат цены зависит от величины цен в viewport
- Автоматическое округление до "красивых" чисел

## Интеграция с системой координат

### Использование ViewportClippingCoords
```csharp
// Временные границы из viewport
DateTime minTime = viewport.minTime;
DateTime maxTime = viewport.maxTime;

// Ценовые границы из viewport
double minPrice = viewport.minPrice;
double maxPrice = viewport.maxPrice;
```

### Конвертация координат
- Использует существующие методы `ChartToView()`
- Автоматически учитывает текущую позицию камеры
- Корректно работает при панорамировании и масштабировании

## Производительность

### Оптимизации
- Отрисовка только видимых меток
- Проверка границ перед отрисовкой
- Кэширование вычислений интервалов
- Минимальное количество операций рисования

### Рекомендации
- Система автоматически ограничивает количество меток (≈8 штук)
- Избегает перегрузки интерфейса при экстремальных масштабах
- Обеспечивает читаемость при любом уровне zoom